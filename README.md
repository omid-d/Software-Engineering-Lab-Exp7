# Software-Engineering-Lab-Exp7

## بخش اول


## بخش دوم

### سوال اول
**هر یک از مفاهیم زیر را در حد یک خط توضیح دهید:**
- کد تمیز:
- بدهی فنی:
- بوی بد:

### سوال دوم
**طبق دسته بندی وبسایت [refactoring.guru](https://refactoring.guru/refactoring/smells) بوهای بد کد به پنج دسته تقسیم میشوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.**

1. متورم‌ها (`Bloaters`)

    متورم‌ها به نوعی از بوی بد کد گفته می‌شود که در آن بخش‌هایی از برنامه مثل کلاس‌ها، متدها یا لیست پارامترها به شکلی بیش از حد بزرگ و پیچیده شده‌اند. این وضعیت معمولاً زمانی به‌وجود می‌آید که برنامه به‌مرور توسعه داده شده، اما طراحی اولیه بازنگری نشده است. با گذشت زمان، کلاس‌ها مسئولیت‌های زیادی را بر عهده می‌گیرند، متدها چندین کار را هم‌زمان انجام می‌دهند و توسعه‌دهندگان پارامترهای بیشتری به توابع اضافه می‌کنند تا نیازهای جدید را پوشش دهند. این مسئله خوانایی کد را کاهش داده، اشکال‌زدایی را دشوار می‌کند و مانع از تست‌پذیری مناسب می‌شود.

    برای مثال، یک کلاس که شامل ۲۰۰۰ خط کد است و کارهای مختلفی مانند مدیریت داده، ارتباط با پایگاه داده و کنترل واسط کاربر را هم‌زمان انجام می‌دهد، نمونه‌ای از یک کلاس متورم (`Large Class`) است. یا متدی که شامل ۱۰۰ خط کد است و چندین وظیفه را هم‌زمان انجام می‌دهد (مثلاً محاسبه قیمت، چاپ فاکتور و ارسال ایمیل) یک متد طولانی (`Long Method`) محسوب می‌شود. همچنین اگر متدی پارامترهایی مانند calculate(a, b, c, d, e, f) دریافت کند، می‌تواند نشانه‌ی یک لیست پارامتر طولانی (`Long Parameter List`) باشد.

2. سوءاستفاده‌کنندگان از شی‌گرایی (`Object-Orientation Abusers`)

    این دسته از بوی بد کدها مربوط به حالتی است که اصول شی‌گرایی به‌درستی استفاده نشده یا به شکلی ناقص یا نادرست پیاده‌سازی شده‌اند. در بسیاری از موارد، توسعه‌دهندگان مفاهیم کلیدی شی‌گرایی مانند وراثت، ترکیب و کپسوله‌سازی را اشتباه به‌کار می‌گیرند یا صرفاً از آن‌ها ظاهری استفاده می‌کنند بدون اینکه ساختار واقعی شی‌گرایانه را پیاده‌سازی کرده باشند.

    برای مثال، یک کلاس فقط شامل مجموعه‌ای از فیلدها است که هیچ منطق رفتاری ندارد و صرفاً داده‌ها را نگه می‌دارد؛ این نوع کلاس‌ها به عنوان Data Class شناخته می‌شوند. یا حالتی که یک کلاس فرزند، فقط به دلیل نیاز به توارث ایجاد شده، ولی هیچ‌کدام از متدهای کلاس والد را استفاده نمی‌کند و حتی برخی از آن‌ها را override کرده و تغییر داده، نمونه‌ای از `Refused Bequest` است. همچنین وقتی دو کلاس تقریباً عملکرد مشابهی دارند ولی رابط‌های متفاوتی دارند که با هم قابل ترکیب نیستند (`Alternative Classes with Different Interfaces`)، این نشانه‌ای از طراحی نادرست شی‌گرایانه است.

3. موانع تغییر (`Change Preventers`)

    موانع تغییر بوی بدهایی هستند که باعث می‌شوند حتی یک تغییر ساده در کد، منجر به تغییرات گسترده و خطرناک در قسمت‌های مختلف سیستم شود. این وضعیت معمولاً به دلیل طراحی ضعیف، وابستگی زیاد بین اجزای سیستم، یا تمرکز چندین مسئولیت در یک کلاس ایجاد می‌شود. وجود این نوع بوها، توانایی توسعه‌دهنده در اعمال تغییرات سریع، ایمن و با اعتماد بالا را از بین می‌برد.

    برای مثال، اگر بخواهید نام یک فیلد یا متد را تغییر دهید، اما مجبور شوید آن را در ۱۰ کلاس مختلف ویرایش کنید، با پدیده‌ای به نام `Shotgun Surgery` روبه‌رو هستید. یا زمانی که برای اضافه کردن یک ویژگی جدید باید فقط یک کلاس خاص را تغییر دهید، ولی چون آن کلاس چندین وظیفه مختلف دارد، مجبورید بخش‌های زیادی از آن را بازنویسی کنید، این حالت به نام `Divergent Change` شناخته می‌شود. همچنین اگر سلسله‌مراتب کلاس‌ها به‌گونه‌ای باشد که هر زمان یک کلاس جدید ایجاد می‌کنید، مجبور باشید کلاس‌های مربوط به UI، کنترل، پایگاه داده و ... را هم به همان ترتیب گسترش دهید، با `Parallel Inheritance Hierarchies` مواجه‌اید.

4.
5.

### سوال سوم

### سوال چهارم

### سوال پنجم

### سوال ششم
# Software-Engineering-Lab-Exp7

## بخش اول


## بخش دوم

### سوال اول
**هر یک از مفاهیم زیر را در حد یک خط توضیح دهید:**
- کد تمیز:
- بدهی فنی:
- بوی بد:

### سوال دوم
**طبق دسته بندی وبسایت [refactoring.guru](https://refactoring.guru/refactoring/smells) بوهای بد کد به پنج دسته تقسیم میشوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.**

1. متورم‌ها (`Bloaters`)

    متورم‌ها به نوعی از بوی بد کد گفته می‌شود که در آن بخش‌هایی از برنامه مثل کلاس‌ها، متدها یا لیست پارامترها به شکلی بیش از حد بزرگ و پیچیده شده‌اند. این وضعیت معمولاً زمانی به‌وجود می‌آید که برنامه به‌مرور توسعه داده شده، اما طراحی اولیه بازنگری نشده است. با گذشت زمان، کلاس‌ها مسئولیت‌های زیادی را بر عهده می‌گیرند، متدها چندین کار را هم‌زمان انجام می‌دهند و توسعه‌دهندگان پارامترهای بیشتری به توابع اضافه می‌کنند تا نیازهای جدید را پوشش دهند. این مسئله خوانایی کد را کاهش داده، اشکال‌زدایی را دشوار می‌کند و مانع از تست‌پذیری مناسب می‌شود.

    برای مثال، یک کلاس که شامل ۲۰۰۰ خط کد است و کارهای مختلفی مانند مدیریت داده، ارتباط با پایگاه داده و کنترل واسط کاربر را هم‌زمان انجام می‌دهد، نمونه‌ای از یک کلاس متورم (`Large Class`) است. یا متدی که شامل ۱۰۰ خط کد است و چندین وظیفه را هم‌زمان انجام می‌دهد (مثلاً محاسبه قیمت، چاپ فاکتور و ارسال ایمیل) یک متد طولانی (`Long Method`) محسوب می‌شود. همچنین اگر متدی پارامترهایی مانند calculate(a, b, c, d, e, f) دریافت کند، می‌تواند نشانه‌ی یک لیست پارامتر طولانی (`Long Parameter List`) باشد.

2. سوءاستفاده‌کنندگان از شی‌گرایی (`Object-Orientation Abusers`)

    این دسته از بوی بد کدها مربوط به حالتی است که اصول شی‌گرایی به‌درستی استفاده نشده یا به شکلی ناقص یا نادرست پیاده‌سازی شده‌اند. در بسیاری از موارد، توسعه‌دهندگان مفاهیم کلیدی شی‌گرایی مانند وراثت، ترکیب و کپسوله‌سازی را اشتباه به‌کار می‌گیرند یا صرفاً از آن‌ها ظاهری استفاده می‌کنند بدون اینکه ساختار واقعی شی‌گرایانه را پیاده‌سازی کرده باشند.

    برای مثال، یک کلاس فقط شامل مجموعه‌ای از فیلدها است که هیچ منطق رفتاری ندارد و صرفاً داده‌ها را نگه می‌دارد؛ این نوع کلاس‌ها به عنوان Data Class شناخته می‌شوند. یا حالتی که یک کلاس فرزند، فقط به دلیل نیاز به توارث ایجاد شده، ولی هیچ‌کدام از متدهای کلاس والد را استفاده نمی‌کند و حتی برخی از آن‌ها را override کرده و تغییر داده، نمونه‌ای از `Refused Bequest` است. همچنین وقتی دو کلاس تقریباً عملکرد مشابهی دارند ولی رابط‌های متفاوتی دارند که با هم قابل ترکیب نیستند (`Alternative Classes with Different Interfaces`)، این نشانه‌ای از طراحی نادرست شی‌گرایانه است.

3. موانع تغییر (`Change Preventers`)

    موانع تغییر بوی بدهایی هستند که باعث می‌شوند حتی یک تغییر ساده در کد، منجر به تغییرات گسترده و خطرناک در قسمت‌های مختلف سیستم شود. این وضعیت معمولاً به دلیل طراحی ضعیف، وابستگی زیاد بین اجزای سیستم، یا تمرکز چندین مسئولیت در یک کلاس ایجاد می‌شود. وجود این نوع بوها، توانایی توسعه‌دهنده در اعمال تغییرات سریع، ایمن و با اعتماد بالا را از بین می‌برد.

    برای مثال، اگر بخواهید نام یک فیلد یا متد را تغییر دهید، اما مجبور شوید آن را در ۱۰ کلاس مختلف ویرایش کنید، با پدیده‌ای به نام `Shotgun Surgery` روبه‌رو هستید. یا زمانی که برای اضافه کردن یک ویژگی جدید باید فقط یک کلاس خاص را تغییر دهید، ولی چون آن کلاس چندین وظیفه مختلف دارد، مجبورید بخش‌های زیادی از آن را بازنویسی کنید، این حالت به نام `Divergent Change` شناخته می‌شود. همچنین اگر سلسله‌مراتب کلاس‌ها به‌گونه‌ای باشد که هر زمان یک کلاس جدید ایجاد می‌کنید، مجبور باشید کلاس‌های مربوط به UI، کنترل، پایگاه داده و ... را هم به همان ترتیب گسترش دهید، با `Parallel Inheritance Hierarchies` مواجه‌اید.

4. کدهای غیرضروری (`Dispensables`)

    کدهای غیرضروری آن بخش‌هایی از کد هستند که حذف آن‌ها نه‌تنها عملکرد برنامه را تحت تأثیر قرار نمی‌دهد، بلکه باعث خواناتر شدن، کاهش پیچیدگی و آسان‌تر شدن نگهداری کد خواهد شد. این کدها یا زمانی مفید بوده‌اند ولی اکنون بلااستفاده‌اند، یا از ابتدا صرفاً برای جبران ضعف طراحی نوشته شده‌اند.

    یکی از متداول‌ترین مثال‌ها، `Dead Code` است: متدهایی که هیچ‌گاه فراخوانی نمی‌شوند، شرط‌هایی که هرگز به واقعیت نمی‌پیوندند، یا متغیرهایی که هرگز استفاده نمی‌شوند. یا کامنت‌هایی که به‌جای واضح‌تر کردن کد، تلاش می‌کنند عملکرد پیچیده‌ی آن را توضیح دهند، در حالی که می‌شد با بهبود نام‌گذاری یا ساده‌سازی کد از کامنت بی‌نیاز شد. همچنین تکرار کد در چند بخش مختلف برنامه (`Duplicate Code`)، به‌جای استخراج آن به یک تابع مشترک، نیز نوعی از `Dispensible` محسوب می‌شود.

5. وابستگی‌های نامطلوب (`Couplers`)

    این نوع بوی بد زمانی رخ می‌دهد که اجزای مختلف نرم‌افزار به شکل ناسالمی به هم وابسته‌اند. در این حالت، کلاس‌ها یا ماژول‌ها اطلاعات زیادی درباره‌ی یکدیگر دارند، یا برای عملکرد صحیح، نیاز به تعامل مکرر و پیچیده دارند. این وابستگی‌ها مانع از انعطاف‌پذیری و قابلیت گسترش سیستم می‌شوند.

    برای نمونه، اگر یک کلاس دائم به داده‌های داخلی یک کلاس دیگر دسترسی دارد و از متدهای آن سوءاستفاده می‌کند، با پدیده‌ای به نام Feature Envy روبه‌رو هستید. یا اگر دو کلاس بیش از حد به هم نزدیک شده‌اند و پیوسته وضعیت یکدیگر را تغییر می‌دهند، به آن `Inappropriate Intimacy` گفته می‌شود. همچنین اگر در کدی زنجیره‌ای از متدهای دسترسی وجود داشته باشد مثل `obj.getA().getB().getC()،` این `Message Chain` می‌تواند نشانه‌ای از وابستگی بیش از حد و طراحی ضعیف باشد.

### سوال سوم

### سوال چهارم

### سوال پنجم
**در وبسایت 29 بوی بد کد نامبرده شده است. سعی کنید 10بوی بد را در پروژه تبدیل کننده مدل به سی پیدا کنید و به آن اشاره کنید.**

1. **Feature Envy**

در کلاس `Main`، متد `loopOnGUI` دچار بوی بد `Feature Envy` است، زیرا بیشتر به داده‌ها و متدهای کلاس `GUIDiagram` وابسته است تا به اعضای کلاس خود.

![feature_envy](src/main/pics/featurre_envy.png)

2. **Duplicate Code**

در کلاس `Main`، منطق مربوط به بررسی و نمایش وضعیت `BasicDiagramStatus` و پردازش نتایج `GraphOperation` در دو متد `generateInfoForXML` و `loopOnGUI` به‌صورت تکراری پیاده‌سازی شده است. این تکرار کد (که نوعی بوی بد کد از نوع Duplicate Code محسوب می‌شود) باعث افزایش پیچیدگی، دشواری در نگهداری و احتمال بروز خطا در صورت نیاز به تغییرات آتی می‌شود. به عنوان نمونه، در هر دو متد، کدهایی برای استخراج وضعیت دیاگرام، چاپ کد وضعیت، بررسی تعداد وابستگی‌ها، نمایش چرخه‌ها و تولید کد وجود دارد که ساختار و منطق مشابهی دارند. برای رفع این مشکل و بهبود خوانایی و قابلیت نگهداری کد، پیشنهاد می‌شود این منطق‌های تکراری در قالب متدهای مستقل استخراج شوند و در هر دو متد فراخوانی شوند. این کار ضمن کاهش افزونگی، امکان اعمال تغییرات آینده را ساده‌تر و امن‌تر خواهد کرد.

![dup1](src/main/pics/featurre_envy.png)
![dup2](src/main/pics/duplicated_code.png)

همچنین در سازنده کلاس `Phase2CodeGenerator`، منطق جست‌وجو و افزودن فایل‌ها از دایرکتوری‌های مختلف چندین بار با ساختاری تقریباً یکسان تکرار شده است. تنها تفاوت در نوع فایل‌ها (.c, .h, .cpp) و نوع فایل ارسالی به متد `addPath` است. این تکرار کد نشان‌دهنده‌ی بوی بد `Duplicated Code` است که باعث کاهش خوانایی و افزایش هزینه‌ی نگهداری کد می‌شود. با انتقال این منطق به یک متد عمومی، می‌توان از تکرار جلوگیری کرد و کد را تمیزتر و قابل‌توسعه‌تر ساخت.

![dup2](src/main/pics/dup2.png)

3. **Magic Numbers**

اعداد هاردکد شده در فایل `Main.java` بسیار زیاد دیده می‌شوند. در کد کلاس `Main` چند عدد جادویی وجود دارد که بدون توضیح یا نام مشخص مستقیماً در منطق برنامه استفاده شده‌اند و این موضوع باعث کاهش خوانایی و نگهداری‌پذیری کد می‌شود. مثلاً عدد ۱۵ در متد `loopOnGUI` برای شرط `counter % 15 == 0` استفاده شده که می‌توان آن را به یک ثابت معنادار مانند `GUI_UPDATE_INTERVAL` تبدیل کرد. همچنین عدد ۴ در همین متد برای شرط `counter % 4 == 0` به کار رفته که پیشنهاد می‌شود به صورت ثابتی مثل `CODE_GENERATION_INTERVAL` تعریف شود. عدد ۱۹۹۹ نیز در متد `run()` برای تأخیر در اجرای حلقه استفاده شده که بهتر است با نامی مانند `SLEEP_DURATION_MS` جایگزین شود تا مفهوم آن روشن‌تر باشد. علاوه بر این‌ها، مقادیر ۱۵۰۰ و ۷۵۰ که برای تعیین اندازه پنجره `GUI` به کار رفته‌اند نیز باید به صورت ثابت‌هایی مانند `WINDOW_WIDTH` و `WINDOW_HEIGHT` تعریف شوند. در نهایت، رشته‌هایی مانند `"diagram_info"، "phase1"، "c_files" و "headers"` نیز که به صورت مستقیم در منطق `main` استفاده شده‌اند، می‌توانند به صورت کانستنت تعریف شوند تا هم خوانایی افزایش یابد و هم تغییر آن‌ها در آینده ساده‌تر باشد.

4. **Large Class and Long Method:**

در این پروژه برخی کلاس‌ها بسیار بزرگ هستند و مسئولیت‌های متعددی را بر عهده دارند، همچنین تعدادی از متدها نیز بیش از حد طولانی‌اند که باعث کاهش خوانایی، افزایش پیچیدگی و دشواری در نگهداری کد شده است. چند تصویر از تعداد خطوط بعضی از توابع و کلاس‌ها مشاهده می‌شود.

![large1](src/main/pics/large1.png)
![large2](src/main/pics/large2.png)
![large3](src/main/pics/large3.png)

5.

6.

7.

8.

9.

10.

### سوال ششم